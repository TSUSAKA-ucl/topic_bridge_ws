<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>WebXR Controller Pose WebSocket Sender</title>
  <!--
  <style>
    .a-enter-vr-button {
      top: auto !important;
      bottom: 20px !important;
      right: 20px !important;
      z-index: 9999;
    }
  </style>
  -->
  <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
  <script src="/js/msgpack.min.js"></script>
</head>
<body>
  <!--
  <a-scene embedded vr-mode-ui="enabled: true" renderer="logarithmicDepthBuffer: true">
    -->
  <a-scene>
    <a-box position="0 1.5 -2" rotation="0 45 0" color="#4CC3D9"></a-box>
    <a-sky color="#ECECEC"></a-sky>
    <!-- カメラ+コントローラ -->
    <a-entity id="cameraRig" position="0 1.6 0">
      <a-camera id="camera" wasd-controls-enabled="false"></a-camera>
      <a-entity id="rightController" hand-controls="hand: right"></a-entity>
      <a-entity id="leftController" hand-controls="hand: left"></a-entity>
    </a-entity>
  </a-scene>

  <script type="module">
    // import (encode, decode} from "@msgpack/msgpack";
    const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
    const host = location.hostname;
    const port = 9090;  // WebSocketサーバーのポート
    const ws = new WebSocket(`${protocol}//${host}:${port}`);

    ws.onopen = () => {
      console.log('WebSocket connected');
    };
    ws.onerror = (err) => {
      console.error('WebSocket error', err);
    };
    ws.onmessage = function(event) {
      // event.data が ArrayBuffer または Blob で送られてくる場合がある
      let arrayBufferPromise;

      if (event.data instanceof Blob) {
	// console.log('event.data is an instance of Blob');
	// Blob なら ArrayBuffer に変換
	arrayBufferPromise = event.data.arrayBuffer();
      } else if (event.data instanceof ArrayBuffer) {
	arrayBufferPromise = Promise.resolve(event.data);
      } else if (event.data instanceof Uint8Array) {
	arrayBufferPromise = Promise.resolve(event.data.buffer);
      } else {
	console.error('Unknown data type:', event.data);
	return;
      }

      arrayBufferPromise.then(buffer => {
	// Uint8Array に変換して decode
	const uint8 = new Uint8Array(buffer);
	const obj = MessagePack.decode(uint8);
	console.log(obj);
      });
    };

    // コントローラの位置・回転を送信する関数
    function sendControllerPose(controllerEl, hand) {
      if (!controllerEl) return;
      const pos = controllerEl.object3D.position;
      const quat = controllerEl.object3D.quaternion;

      const msg = {
    	topic: 'pose1',
        javascriptStamp: Date.now(),
	header: {
	  frame_id: 'world',
	},
	pose: {
          position: { x: pos.x+1, y: pos.y+2, z: pos.z+3 },
          orientation: { x: quat.x, y: quat.y, z: quat.z, w: quat.w }
	},
      };
      const binary = MessagePack.encode(msg);

      if (ws.readyState === WebSocket.OPEN) {
        ws.send(binary);
      }

      const actMsg = {
	topic: 'actuator1',
        javascriptStamp: Date.now(),
	header: { },
	position: [1.2, 2.3, 3.4],
	velocity: [123, 234, 345],
      }
      const actBin = MessagePack.encode(actMsg);
      if (ws.readyState === WebSocket.OPEN) { ws.send(actBin); }
    }

    // フレームごとに送信
    AFRAME.registerComponent('send-pose', {
      tick: function () {
        const rightController = document.querySelector('#rightController');
        const leftController = document.querySelector('#leftController');

        sendControllerPose(rightController, 'right');
        sendControllerPose(leftController, 'left');
      }
    });

    // シーンにコンポーネント追加して動かす
    document.querySelector('a-scene').setAttribute('send-pose', '');
  </script>
</body>
</html>
